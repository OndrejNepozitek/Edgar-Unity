"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[26],{603905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return h}});var o=a(667294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function n(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,o,l=function(e,t){if(null==e)return{};var a,o,l={},r=Object.keys(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=o.createContext({}),d=function(e){var t=o.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):n(n({},t),e)),a},p=function(e){var t=d(e.components);return o.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=d(a),h=l,u=c["".concat(s,".").concat(h)]||c[h]||m[h]||r;return a?o.createElement(u,n(n({ref:t},p),{},{components:a})):o.createElement(u,n({ref:t},p))}));function h(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,n=new Array(r);n[0]=c;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:l,n[1]=i;for(var d=2;d<r;d++)n[d]=a[d];return o.createElement.apply(null,n)}return o.createElement.apply(null,a)}c.displayName="MDXCreateElement"},179337:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return p},default:function(){return v}});var o=a(487462),l=a(263366),r=(a(667294),a(603905)),n=["components"],i={title:"(PRO) Dead Cells"},s=void 0,d={unversionedId:"examples/dead-cells",id:"examples/dead-cells",title:"(PRO) Dead Cells",description:"In this tutorial, we will look into how to generate levels similar to what we can see in Dead Cells. We will use this tileset by Szadi art. - be sure to check out their work if you like the tileset.",source:"@site/docs/examples/dead-cells.md",sourceDirName:"examples",slug:"/examples/dead-cells",permalink:"/Edgar-Unity/docs/next/examples/dead-cells",editUrl:"https://github.com/OndrejNepozitek/Edgar-Unity/tree/docusaurus/docs/examples/dead-cells.md",tags:[],version:"current",frontMatter:{title:"(PRO) Dead Cells"},sidebar:"docs",previous:{title:"(PRO) Enter the Gungeon",permalink:"/Edgar-Unity/docs/next/examples/enter-the-gungeon"},next:{title:"Room template customization",permalink:"/Edgar-Unity/docs/next/guides/room-template-customization"}},p=[{value:"Prerequisites",id:"prerequisites",children:[],level:2},{value:"Introduction",id:"introduction",children:[],level:2},{value:"Underground level",id:"underground-level",children:[{value:"Room templates",id:"room-templates",children:[{value:"Corridors",id:"corridors",children:[],level:4}],level:3},{value:"Level graph",id:"level-graph",children:[],level:3},{value:"Custom room and connection types",id:"custom-room-and-connection-types",children:[],level:3},{value:"Input setup",id:"input-setup",children:[],level:3},{value:"Spawn position",id:"spawn-position",children:[],level:3},{value:"Enemies",id:"enemies",children:[],level:3},{value:"Level map",id:"level-map",children:[],level:3},{value:"Results",id:"results",children:[],level:3}],level:2},{value:"Rooftop level",id:"rooftop-level",children:[{value:"Towers",id:"towers",children:[{value:"Room templates",id:"room-templates-1",children:[],level:4},{value:"Level graph",id:"level-graph-1",children:[],level:4},{value:"Intermediate results",id:"intermediate-results",children:[],level:4},{value:"Walls",id:"walls",children:[],level:4}],level:3},{value:"Rooms inside towers",id:"rooms-inside-towers",children:[{value:"Room templates",id:"room-templates-2",children:[],level:4},{value:"Level graph",id:"level-graph-2",children:[],level:4}],level:3},{value:"Results",id:"results-1",children:[],level:3}],level:2}],m=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)}},c=m("Image"),h=m("Path"),u=m("ExampleFeatures"),g=m("Gallery"),w=m("ExternalCode"),y={toc:p};function v(e){var t=e.components,a=(0,l.Z)(e,n);return(0,r.kt)("wrapper",(0,o.Z)({},y,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this tutorial, we will look into how to generate levels similar to what we can see in ",(0,r.kt)("a",{parentName:"p",href:"https://store.steampowered.com/app/588650/Dead_Cells/"},"Dead Cells"),". We will use ",(0,r.kt)("a",{parentName:"p",href:"https://szadiart.itch.io/pixel-platformer-castle"},"this tileset")," by ",(0,r.kt)("a",{parentName:"p",href:"https://szadiart.itch.io/"},"Szadi art.")," - be sure to check out their work if you like the tileset."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Disclaimer:")," We are in no way affiliated with the authors of the Dead Cells game and this plugin is not used in the game. This is only a case study about how to use this plugin to create something similar to what is done in that game.")),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground_result1.png",caption:"Underground level generated by our algorithm, inspired by the Prisoners Quarters level from Dead Cells",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/ramparts_result1.png",caption:"Rooftop level generated by our algorithm, inspired by the Ramparts level from Dead Cells",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/ramparts_ingame.png",caption:"Rooftop level generated by our algorithm, ingame view",mdxType:"Image"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," All files from this example can be found at ",(0,r.kt)(h,{path:"2de:Metroidvania",mdxType:"Path"}),".")),(0,r.kt)(u,{id:"dead-cells",mdxType:"ExampleFeatures"}),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"To run the example, you need to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add a layer called ",(0,r.kt)("em",{parentName:"li"},'"StaticEnvironment"')),(0,r.kt)("li",{parentName:"ul"},"Enable ",(0,r.kt)("em",{parentName:"li"},'"Auto Sync Transforms"')," in Physics2D settings")),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Dead Cells is a rogue-lite, Metroidvania inspired, action-platformer. They use procedural generation techniques to generate levels of the game. An article about their approach can be found ",(0,r.kt)("a",{parentName:"p",href:"https://www.indiedb.com/games/dead-cells/news/the-level-design-of-a-procedurally-generated-metroidvania"},"here")," and a video ",(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=tyMrRW-Li_I"},"here"),"."),(0,r.kt)("p",null,"The main idea is that they have hand-made room templates and a graph that describes the structure of the level. Both the room templates and the graph are usually different for each stage of the game. Their procedural generator is then guided by the graph of rooms and picks a random room template for each room. This approach is very similar to what we do in our algorithm."),(0,r.kt)(c,{src:"2d/examples/dead_cells/original_sewers_graph.png",caption:"Graph that describes the structure of the Sewers level in Dead Cells",mdxType:"Image"}),(0,r.kt)("h2",{id:"underground-level"},"Underground level"),(0,r.kt)("p",null,"The first level that we will try to implement with our plugin is an underground level inspired by the Prisoners Quarters level from Dead Cells."),(0,r.kt)(c,{src:"2d/examples/dead_cells/original_prisoners_quarters.png",caption:"Prisoners Quarters level map from Dead Cells",mdxType:"Image"}),(0,r.kt)("h3",{id:"room-templates"},"Room templates"),(0,r.kt)("p",null,"We use the default platformer tilemap layers handler to create the room templates."),(0,r.kt)(g,{cols:2,fixedHeight:!0,mdxType:"Gallery"},(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/entrance.png",caption:"Entrance",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/exit.png",caption:"Exit",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/room4.png",caption:"Normal room",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/shop1.png",caption:"Shop",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/teleport2.png",caption:"Teleport",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/treasure1.png",caption:"Treasure",mdxType:"Image"})),(0,r.kt)("h4",{id:"corridors"},"Corridors"),(0,r.kt)("p",null,"We use simple corridors to connect individual rooms."),(0,r.kt)(g,{cols:2,fixedHeight:!0,mdxType:"Gallery"},(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/hor.png",caption:"Horizontal corridor",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/ver.png",caption:"Vertical corridor",mdxType:"Image"})),(0,r.kt)("p",null,"There is a slight problem with the corners of the corridor and the tileset that we use. In the image below, you can see that if the room that is connected with the corridor has a different height than the corridor, we should use a proper corner tile. We currently do not handle this situation, but it could be solved by using rule tiles or by writing a post-processing logic that would find these problems and fix them."),(0,r.kt)(c,{src:"2d/examples/dead_cells/corridor_problem.png",caption:"Problem with corridor corners",mdxType:"Image"}),(0,r.kt)("h3",{id:"level-graph"},"Level graph"),(0,r.kt)("p",null,"Our underground level is inspired by the Prisoners Quarters level in Dead Cells. The level graph below was created by analysing the structure of several generated levels and then trying to replicate the main features. "),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground_level_graph.png",caption:"Level graph for the underground level",mdxType:"Image"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," It seems like the structure of the level may slightly differ between individual runs of the game. For example, the positions of the shop room and the treasure room may be swapped. However, to keep it simple, we will use a fixed level graph. You can see the ",(0,r.kt)("a",{parentName:"p",href:"/Edgar-Unity/docs/next/examples/enter-the-gungeon"},"Enter the Gungeon")," for an example of procedurally generated levels.")),(0,r.kt)("h3",{id:"custom-room-and-connection-types"},"Custom room and connection types"),(0,r.kt)("p",null,"In the level graph above, we used custom room and connection types. The implementation of the custom room type can be seen below. Each room has its type (entrance, treasure, etc) and also a flag that indicates where it is outside (which is used for rooftop levels). Additionally, we override the ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString()")," implementation so that the type of room is displayed in the level graph."),(0,r.kt)(w,{name:"2d_metroidvania_room",mdxType:"ExternalCode"}),(0,r.kt)("p",null,"We also have a custom connection type. It currently looks exactly like the default implementation, but we use it just in case we need some additional functionality later."),(0,r.kt)("h3",{id:"input-setup"},"Input setup"),(0,r.kt)("p",null,"We decided to use a custom input setup to prepare our inputs. The main idea is the following. We create a level graph as we would normally do, but we do not assign any room templates to it. Instead, we create a custom input task that takes a level graph as an input, together with the mapping between the type of room and the available room templates. The implementation will go through individual rooms in the level graph and based on their type it will assign corresponding room templates."),(0,r.kt)("p",null,"First, we create the mapping between the type of the room and the available room templates:"),(0,r.kt)(w,{name:"2d_metroidvania_roomTemplatesConfig",mdxType:"ExternalCode"}),(0,r.kt)("p",null,"And then we create a simple input setup task that prepares the level description:"),(0,r.kt)(w,{name:"2d_metroidvania_inputSetup",mdxType:"ExternalCode"}),(0,r.kt)("h3",{id:"spawn-position"},"Spawn position"),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"/Edgar-Unity/docs/next/examples/example-1"},"Example 1"),", we placed the player prefab directly in the Spawn room template to make sure that the player always starts in the correct room. However, there is also a different approach to achieve the same result. Instead of placing the player prefab inside the room template, we simply create an empty GameObject that will act as a marker of the spawn position. We place the player prefab directly into the scene and implement a simple post-processing logic that finds the spawn position marker and moves the player there after the level is generated."),(0,r.kt)(w,{name:"2d_metroidvania_setSpawnPosition",mdxType:"ExternalCode"}),(0,r.kt)("h3",{id:"enemies"},"Enemies"),(0,r.kt)("p",null,"In order to spawn enemies in generated levels, we added an empty GameObject called ",(0,r.kt)("em",{parentName:"p"},"EnemySpawnPositions")," to each room template where we want to spawn enemies. Each empty GameObject that we attach as a child will mark a single position where an enemy can spawn. An advantage of this approach is that we can randomize the process of choosing an enemy for each spawn point."),(0,r.kt)("p",null,"We did not implement any combat, just a simple patrol AI that makes the enemy change its direction if there is a hole or an obstacle ahead."),(0,r.kt)("p",null,"Below you can see a method that we can put inside a post-processing task to handle the spawn of enemies."),(0,r.kt)(w,{name:"2d_metroidvania_spawnEnemies",mdxType:"ExternalCode"}),(0,r.kt)("h3",{id:"level-map"},"Level map"),(0,r.kt)("p",null,"Dead Cells comes with a schematic level map that shows the overview of the whole level with a very simple graphics. This level map also contains positions of all the teleport, treasures, etc. We decided to create something similar (although much simpler) for this tutorial. The result can be seen below:"),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground_result1.png",caption:"Simple level map",mdxType:"Image"}),(0,r.kt)("p",null,"After a level is generated, we create an additional tilemap which will contain all the information about the level map. We go through individual tilemap layers of the level and copy them to the level map tilemap. First, we find all the tiles from the ",(0,r.kt)("em",{parentName:"p"},"Background")," tilemap layer and copy them to the level map. But instead of using the normal graphics of individual tiles, we use a tile that is completely blue. Then we repeat this process with other layers and different colours of tiles."),(0,r.kt)(w,{name:"2d_metroidvania_setupLevelMap",mdxType:"ExternalCode"}),(0,r.kt)("p",null,"The last part of the setup is to create a camera the displays only the level map tilemap layer. To achieve that, we assign a special layer to the tilemap and then set the culling mask. We also added a simple camera control that reacts to players pressing a button and toggles between the default view and the level map view."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," For the level map to work, you need to add a layer called ",(0,r.kt)("strong",{parentName:"p"},"LevelMap"),". Unfortunately, it is impossible to do that from a script.")),(0,r.kt)("h3",{id:"results"},"Results"),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/result1_ingame.png",caption:"Example result - ingame view",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/result1.png",caption:"Example result - level map view",mdxType:"Image"}),(0,r.kt)(g,{cols:2,fixedHeight:!0,mdxType:"Gallery"},(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/result2.png",caption:"Example result",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/underground/result3.png",caption:"Example result",mdxType:"Image"})),(0,r.kt)("h2",{id:"rooftop-level"},"Rooftop level"),(0,r.kt)("p",null,"The second level that we try to implement is a bit different. It is inspired by the Ramparts level from Dead Cells. Instead of being underground, it takes places on the ramparts of the prison. We will have to combine two types of rooms - rooms that are on the roofs of towers and rooms that are inside towers."),(0,r.kt)(c,{src:"2d/examples/dead_cells/original_ramparts.png",caption:"Ramparts level map from Dead Cells",mdxType:"Image"}),(0,r.kt)("h3",{id:"towers"},"Towers"),(0,r.kt)("p",null,"The first challenge of this level is how to generate the top layer of rooms in a way that it looks like there are towers that are divided by gaps. Our goal is to create a set of room templates that can be connected only horizontally and then implement a post-processing logic that will create the illusion of towers."),(0,r.kt)("h4",{id:"room-templates-1"},"Room templates"),(0,r.kt)(g,{cols:2,fixedHeight:!0,mdxType:"Gallery"},(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop/entrance.png",caption:"Entrance",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop/exit.png",caption:"Exit",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop/outside1.png",caption:"Normal",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop/outside3.png",caption:"Normal",mdxType:"Image"})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," It is ",(0,r.kt)("strong",{parentName:"p"},"very important")," that we do not use layers with colliders if it is not necessary. For example, you can see that only the outline tiles of walls have a collider and other walls are in the background layer without a collider. The reason for that is that when the generator assembles the level and copies tiles to shared tilemaps, Unity has to recompute collider shapes which can significantly decrease the performance if there are too tiles with colliders.")),(0,r.kt)("h4",{id:"level-graph-1"},"Level graph"),(0,r.kt)("p",null,"The first version of the level graph contains the top layer of rooms, i.e. only the rooms that are on top of the towers."),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop_level_graph_simple.png",caption:"Level graph with only the top layer of rooms",mdxType:"Image"}),(0,r.kt)("h4",{id:"intermediate-results"},"Intermediate results"),(0,r.kt)("p",null,"Below we can see how the level looks now. All the rooms are connected only horizontally because there are no vertical door positions."),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop_result_towers_intermediate.png",caption:"Intermediate result",mdxType:"Image"}),(0,r.kt)("h4",{id:"walls"},"Walls"),(0,r.kt)("p",null,"The last step is to add wall tiles under individual rooms so that the level looks like there are towers. This can be done with a custom post-processing logic that goes through all the rooms and for each used room template it finds the bottom-most layer of tiles. For each tile position in this layer, if it contains a non-null tile, we add a column of wall tiles under it."),(0,r.kt)(w,{name:"2d_metroidvania_addWalls",mdxType:"ExternalCode"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," Once again, it is ",(0,r.kt)("strong",{parentName:"p"},"very important")," that we use collider for as few tiles as possible. We are adding many tiles and do not want to spend too much time recomputing colliders.")),(0,r.kt)("p",null,"One problem that we have to solve is when we should call this post-processing logic. In the next section, we will add rooms inside the towers. But if we draw walls after all the rooms are drawn, we will overwrite all the rooms that are inside the tower. We would have to do some checks to avoid that. An easier solution is to call our logic after shared tilemaps are initialized but before any rooms are drawn. That means that we first draw the walls and if there is a room occupying the same tiles, the room overwrites the walls, which is what we want. To achieve that, we use ",(0,r.kt)("a",{parentName:"p",href:"/Edgar-Unity/docs/next/generators/post-process#pro-priority-callbacks"},"Priority callbacks")," and register our logic right after shared tilemaps are initialized."),(0,r.kt)(w,{name:"2d_metroidvania_registerCallbacks",mdxType:"ExternalCode"}),(0,r.kt)("p",null,"The resulting level can be seen below:"),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop_result_towers.png",caption:"Towers",mdxType:"Image"}),(0,r.kt)("h3",{id:"rooms-inside-towers"},"Rooms inside towers"),(0,r.kt)("p",null,"The second challenge is how to make sure that if we add rooms inside the towers, they will not cross the boundary of the tower. Unfortunately, it is currently not possible to add such constraints to the generator, so we have to be creative with how we design our room templates."),(0,r.kt)("h4",{id:"room-templates-2"},"Room templates"),(0,r.kt)("p",null,"We will design our room templates in a way that it is not possible for them to cross the borders of towers. To do so, we will place all the doors near to the centre of the room."),(0,r.kt)(g,{cols:2,fixedHeight:!0,mdxType:"Gallery"},(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop/inside1.png",caption:"Inside room",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop/inside2.png",caption:"Inside room",mdxType:"Image"})),(0,r.kt)("p",null,"And we also have to create rooms templates that have some vertical door positions so that we can connect the inside rooms to them."),(0,r.kt)(g,{cols:2,fixedHeight:!0,mdxType:"Gallery"},(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop/outteleport1.png",caption:"Outside room",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop/outteleport2.png",caption:"Outside room",mdxType:"Image"})),(0,r.kt)("h4",{id:"level-graph-2"},"Level graph"),(0,r.kt)("p",null,"Now we can add these inside rooms to the level graph."),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop_level_graph.png",caption:"Level graph with all the rooms",mdxType:"Image"}),(0,r.kt)("h3",{id:"results-1"},"Results"),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop_result1.png",caption:"Example result - level map view",mdxType:"Image"}),(0,r.kt)(c,{src:"2d/examples/dead_cells/rooftop_result1_ingame.png",caption:"Example result - ingame view",mdxType:"Image"}))}v.isMDXComponent=!0}}]);